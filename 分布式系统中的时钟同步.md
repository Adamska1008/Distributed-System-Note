以`make`为例，假如`file.c`修改的时间晚于`file.o`，那么`make`就判断需要编译`file.c`。假如在一个分布式系统上运行这样的软件，就要求整个系统具有统一的时钟或时间戳，而这并非自然达成的。

### 物理时钟

许多电路都有时钟。时钟更接近与计时器，一般是一个周期振荡的石英晶体。每振荡一个周期，便会引起一个寄存器的自减，直到归零则会触发中断，同时寄存器复原。这就是计算器触发定时的方式。

单机系统中所有进程共用一个计数器，即使计数器本身存在误差也不影响时间戳本身的正确性。而多核CPU中，由于每个CPU都带有时钟，每个时钟可能存在微笑偏差，称为 **时钟偏移（clock skew）**。

除了计算机自带的时钟之外，很多情况下计算机会使用外部时钟提供的数据。**协调世界时（Universal Coordinated Time, UTC）** 是国际标准的时间标尺。通过UTC接收器，计算机可以接收UTC短波电台或卫星发送的UTC时间。

### 时钟同步算法

记 $t$ 为UTC时间，$C_p(t)$ 为单机 $p$ 在 $t$ 时的时钟时间，那么时钟同步的目标就是，对于集群中的任意机器 $p$ 、$q$，满足 **精度（precision）** 为 $\pi$。

$$
\forall t, \forall p,q\ :\ \mid C_{p}(t) - C_{q}(t) \mid \le \pi
$$

假设外部具有绝对精准的时钟（一般指UTC），目标也可以表示为将 **准确度（accuracy）** 限制到 $\alpha$

$$
\forall t, \forall p \ :\ \mid C_{p}(t)-t\mid \le\alpha
$$
前者表示内部同步，后者表示外部同步。外部同步的系统保证 $\pi=2\alpha$，但内部精准的系统无法保证外部精准。

对于计算机内部的硬件时钟，由于其不一定完全准确，可能存在 **时钟漂移（clock drift）**。具体来说，我们关注的是 **最大时钟漂移率$\rho$（maximum clock drift rate）**。

记 $F(t)$ 为$t$ 时刻晶振的实际频率，$F$ 是期望频率，则这一规格可以表示为

$$
\forall t\ :\ (1-\rho) \le \cfrac{F(t)}{F}\le (1+\rho)
$$
不难看出

$$
C_{p}(t)=\cfrac{1}{F} \int^{t}_{0}F(t)dt\to \cfrac{dC_{p}(t)}{dt}=\cfrac{F(t)}{t}
$$

故优秀的时钟应保证 $\cfrac{dC_{p}(t)}{dt}$ 在1附近。

### 网络时间协议

网络时间协议（Network Time Protocol，NTP）是一种用于同步时钟的协议。