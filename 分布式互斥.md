
为了保证集群对共享资源的互斥访问，需要采用一些分布式互斥算法。

这些算法基本分为两大类，第一是 **基于令牌的解决方案（Token-based solutions）**，只有持有令牌的成员才能获取共享资源，使用完资源或不需要资源的成员将令牌传递给其他成员。一般而言，令牌具有较好的 **公平性（fairness）**，同时也不容易产生 **死锁**。而其缺点是令牌可能丢失（例如持有令牌的成员机器崩溃），如要恢复令牌需要使用复杂的算法。

第二种是 **基于权限的方法（permisson-based approach）**。即需要资源的进程，首先要从其他进程种中获取许可。

### 中心化算法

对于具有 **协调器（Coordinator）** 的分布式系统，当一个进程想要访问共享资源，需要向协调器发送请求。如果没有其他进程正在使用这个资源，则协调器批准许可。

当无法批准许可时，协调器的行为没有同一规定。例如，可以持续等待，直到前一个进程释放资源，此时再向申请的进程发送ACK包。

一般来说，协调器会记录一个等待队列，当有进程释放资源时令队首出队，获取资源。

中心化算法的缺点是对协调器依赖严重。当协调器崩溃时系统无法正常运行。由于协调器不批准许可的行为是直接阻塞，故其他进程无法区分协调器崩溃和资源正在使用这两种情况。同时，协调器性能可能称为整个分布式系统的性能瓶颈。

### 去中心化算法

去中心化算法与中心化算法完全想法。假设每个资源被复制了N次，每份复制都有独属的协调器来控制访问权限。当一个进程希望获取资源时，需要从N个协调器中获取许可。只要这个许可超过N/2（考虑到协调器可能的崩溃），就允许进程访问资源。

### 全序广播和Lamport互斥算法

对于多个广播事件来说，由于其消息到达不同服务器所花的时间不同，在不同服务器上的顺序也可能不一样。我们希望多个事件的发生顺序，在所有服务器上都是一样的，这称为全序广播（total-ordered multicasting）。

首先，全序广播的消息使用带ID的Lamport时间戳。当进程接收到消息时，先使用一个队列存储所有未确认的消息，队列中的排序方法为依据时间戳升序排序。接下来，接收者向所有成员广播确认并等待回复。只有当一个消息处于队首，且所有成员发送ACK给它之后，这个消息才能发送给应用层。

Lamport互斥的设计基于Lamport时钟，同时使用了全序广播的思想。当一个节点希望访问共享资源时，向其他节点发送包含Lamport时间戳的请求。对于接受放，如果允许发送方进入临界区，则回复确认。发送方在收到足够数量的确认消息后进入互斥区。Lamport互斥是不要求全序的。
### Ricart & Agrawala互斥算法

Ricart & Agrawala互斥需要全局全序。当一个成员需要使用共享资源时，广播一个确认包，包括资源名、进程ID、逻辑时间戳。对于接收方来说，如下处理：
1. 如果接收方不需要获取资源，直接返回ACK
2. 如果接收方正在使用资源，不回复，直到资源使用完毕回复ACK
3. 如果接收方同样在请求资源，则对比二者请求的时间戳。持有最小时间戳的一方可以使用资源，即接收方返回ACK，否则不回复，直到自己使用完毕资源

该算法的问题时，任意成员崩溃导致没有返回ACK，即会导致所有成员无法访问这个临界区。若接收方先返回一个表示收到消息的包，或直接返回拒绝，则可避免这一问题。

同时，这一算法也要求使用全局全序，并且每个成员都必须知道所有成员。因此，这一算法在规模较小的群组中效果较好。

### 令牌环

令牌环是将所有成员组织为环状，通过环传递令牌的资源控制方法。当进程持有令牌时，才能够访问临界区；如果进程对资源没有兴趣，则直接将令牌传向下一个成员。当没有进程希望访问临界区时，令牌在系统中不断传递。

